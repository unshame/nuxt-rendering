# Nuxt 3 Rendering Mode Demos

In Nuxt 3, the website can either be served by the built-in node server generated by `nuxt build`, or generated
statically
with `nuxt build --prerender` (aka `nuxt generate`). The website can also be rendered in spa or ssr modes. Additionally,
for
statically generated websites, payload extraction is available.

This repo lets you play around with different rendering modes.

To install run:

```bash
yarn install
nuxt prepare
```

Each script in package.json will build the demo website in a different mode and run it
on [http://localhost:3000](http://localhost:3000) for `*:build` script or
[http://localhost:5000](http://localhost:5000) for `*:generate` script.

## Rendering Modes

### SPA

Or [Client-side only rendering](https://nuxt.com/docs/guide/concepts/rendering#client-side-only-rendering).
In this mode the content is generated on the client, while the server serves an empty HTML document.
Prerendering in this mode simply generates an empty HTML document for every route.
This mode is not considered as it leads to poorer SEO.

```bash
yarn run spa:build # http://localhost:3000
# or
yarn run spa:generate # http://localhost:5000
```

### SSR without prerendering

Or [Universal Rendering mode](https://nuxt.com/docs/guide/concepts/rendering#universal-rendering). In this mode, when
the user first enters the website, the content is generated on the server and hydrated on the client. This makes it so
the client doesn't need to render this initial page or make any fetch requests, as they are made on the server. The
server can also cache the HTML output as well as the results of the fetch requests required to render it. However, after
the user navigates to a different page, the app acts as an SPA with HTML being rendered and fetch requests being made on
the client. Additionally, any user-specific information is usually also rendered on the client side to allow caching
rendered pages on the server.

```bash
yarn run ssr:build # http://localhost:3000
```

### SSR with prerendering and payload extraction

Or [Static site generation (SSG)](https://nuxt.com/docs/getting-started/deployment#static-hosting). In this mode, all
pages are generated at build time. Additionally, the results of all fetch requests required to render the pages are
extracted into separate payload.js files for each page. This means two things: (1) the website can be served statically
without a node server in front of it and (2) the client doesn't make any fetch requests when navigating between pages
thanks to payload extraction. However, after the user navigates to a different page, it is still rendered client-side
and fetch requests made after the page is rendered can still be made on the client. What this means is that the website
can be fully rendered at build time while still allowing for authorization and user-specific content on the client.
Additionally, certain pages can
be [excluded from static generation](https://nuxt.com/docs/api/configuration/nuxt-config#exclude) and served as SPA.

```bash
yarn run ssr:generate # http://localhost:5000
```

### SSR with prerendering without payload extraction

The only difference here versus the mode above is that, when the user
navigates to a different page on the website, the fetch requests required to render the page will be made on the client.
This mode shouldn’t be considered as it creates inconsistent results depending on how the user navigates to a page.

```bash
yarn run ssr-no-payload:generate # http://localhost:5000
# Note there's also `yarn run ssr-no-payload:build` but it is exactly the same as SSR without prerendering
```

### SSR with only some pages prerendered

Or [Hybrid rendering](https://nuxt.com/docs/guide/concepts/rendering#new-rendering-patterns-in-nuxt-3). This allows
prerendering a subset of pages at build time.
Importantly, this doesn't allow extracting payloads for prerendered pages, meaning that when navigating to a prerendered
page from a different page, all fetch requests required for rendering it will be made on the client. Overall, it doesn't
really seem like a hybrid mode, rather a slight optimization on top of SSR without prerendering. Without payload
extraction, it seems the only use of this mode is to prerender fully static pages that don’t make any fetch requests
(such as about pages), as otherwise there will be inconsistent results depending on how the user navigates to a page.

```bash
yarn run hybrid:build # http://localhost:3000
# Note there's also `yarn run hybrid:generate` but it is exactly the same as SSR with prerendering and payload extraction
```

## Structure of the demo

The demo consists of 3 pages: `index`, `page1` and `page2`. All pages share the same `default` layout. Each page has
links to all other pages.
There's a REST api running on `/api` with a single `/api/test` endpoint returning the following data:

```typescript
type Response = {
    timestamp: number; // the timestamp when the request was handled
    from: string; // the `from` query parameter of the request, indicating from which page/layout the request was made
}
```

When the api is hit with a request, it prints `hit /api/test from ${from}` to the terminal window.

When the layout is rendered, it makes a request to `/api/test` and puts the result in a global state storage
with `useState`. Pages `page1` and `page2` also make a request to `/api/test` when rendered, and then render the result
of their own request, as well as the result from the global state storage.

## What to note when running the demo

You will see the requests made from each page and the layout in the Network tab of the browser's Dev Tools under
Fetch/XHR filter and/or in the terminal window running the app, depending on whether the request was made client-side or
server-side. Additionally, you will see extracted payloads in the same tab in the Dev Tools under the JS filter as
_payload.js. Reloading the page will force server-side rendering, while navigating to a page via links on the page will
lead to client-side rendering. The behavior of all of this will depend on which mode the app is running in.
